import type { Database } from '@infrastructure/database/connection.js'
import { DrizzleTeamRepository } from '@infrastructure/database/repositories/DrizzleTeamRepository.js'
import { buildTeam } from '@infrastructure/testing/index.js' // ðŸ‘ˆ Using the new Builder
import { setupTestEnvironment } from '@infrastructure/testing/test-helpers.js'
import { expectSuccess } from '@team-pulse/shared/testing/helpers'
import { sql } from 'drizzle-orm'
import { beforeAll, beforeEach, describe, expect, it } from 'vitest'

describe('DrizzleTeamRepository - Integration Tests', () => {
  let repository: DrizzleTeamRepository
  let db: Database

  const { getDatabase } = setupTestEnvironment()

  beforeAll(() => {
    db = getDatabase()
    repository = DrizzleTeamRepository.create({ db })
  })

  beforeEach(async () => {
    // Clean up teams table before each test
    await db.execute(sql`TRUNCATE TABLE teams RESTART IDENTITY CASCADE`)
  })

  describe('save', () => {
    it('should insert a new team successfully', async () => {
      // Arrange
      const team = buildTeam() // Generates valid dynamic data

      // Act
      const result = await repository.save({ team })

      // Assert
      const savedTeam = expectSuccess(result)

      // Direct comparison (Branded Types are strings at runtime)
      expect(savedTeam.id).toBe(team.id)
      expect(savedTeam.name.getValue()).toBe(team.name.getValue())
      expect(savedTeam.city.getValue()).toBe(team.city.getValue())
      expect(savedTeam.foundedYear?.getValue()).toBe(team.foundedYear?.getValue())

      expect(savedTeam.createdAt).toBeInstanceOf(Date)
      expect(savedTeam.updatedAt).toBeInstanceOf(Date)
    })

    it('should update an existing team (upsert)', async () => {
      // Arrange - Create initial team
      const team = buildTeam()

      await repository.save({ team })

      // Create updated team with same ID
      const updatedTeam = buildTeam({ id: team.id })

      // Act - Save again (upsert)
      const result = await repository.save({ team: updatedTeam })

      // Assert
      const savedTeam = expectSuccess(result)
      expect(savedTeam.name.getValue()).toBe(updatedTeam.name.getValue())
      expect(savedTeam.city.getValue()).toBe(updatedTeam.city.getValue())
      expect(savedTeam.foundedYear?.getValue()).toBe(updatedTeam.foundedYear?.getValue())

      // Verify only one team exists
      const allTeams = expectSuccess(await repository.findAll())
      expect(allTeams).toHaveLength(1)
    })

    it('should save a team without founded year', async () => {
      // Arrange
      const team = buildTeam({ foundedYear: null })

      // Act
      const result = await repository.save({ team })

      // Assert
      const savedTeam = expectSuccess(result)
      expect(savedTeam.foundedYear).toBeNull()
    })
  })

  describe('findById', () => {
    it('should find a team by id when it exists', async () => {
      // Arrange
      const team = buildTeam()
      await repository.save({ team })

      // Act
      const result = await repository.findById({ id: team.id })

      // Assert
      const foundTeam = expectSuccess(result)
      expect(foundTeam).not.toBeNull()
      expect(foundTeam?.id).toBe(team.id)
      expect(foundTeam?.name.getValue()).toBe(team.name.getValue())
    })

    it('should return null when team does not exist', async () => {
      // Act
      // We pass a random ID generated by the builder's helper or manually
      const randomTeam = buildTeam()
      const result = await repository.findById({ id: randomTeam.id })

      // Assert
      const foundTeam = expectSuccess(result)
      expect(foundTeam).toBeNull()
    })
  })

  describe('findByName', () => {
    it('should find a team by name when it exists', async () => {
      // Arrange
      const team = buildTeam()
      await repository.save({ team })

      // Act
      const result = await repository.findByName({ name: team.name.getValue() })

      // Assert
      const foundTeam = expectSuccess(result)
      expect(foundTeam).not.toBeNull()
      expect(foundTeam?.id).toBe(team.id)
    })

    it('should return null when team does not exist', async () => {
      // Act
      const result = await repository.findByName({ name: 'Non-existent Team' })

      // Assert
      const foundTeam = expectSuccess(result)
      expect(foundTeam).toBeNull()
    })

    it('should be case-sensitive when finding by name', async () => {
      // Arrange
      // Ensure we create a name that has uppercase letters to test case sensitivity
      const team = buildTeam({ name: 'Real Madrid' })
      await repository.save({ team })

      // Act - Search with different case
      const result = await repository.findByName({ name: 'real madrid' })

      // Assert - Should not find team (case-sensitive)
      const foundTeam = expectSuccess(result)
      expect(foundTeam).toBeNull()
    })
  })

  describe('existsByName', () => {
    it('should return true when team exists', async () => {
      // Arrange
      const team = buildTeam()
      await repository.save({ team })

      // Act
      const result = await repository.existsByName({ name: team.name.getValue() })

      // Assert
      expect(expectSuccess(result)).toBe(true)
    })

    it('should return false when team does not exist', async () => {
      // Act
      const result = await repository.existsByName({ name: 'Non-existent Team' })

      // Assert
      expect(expectSuccess(result)).toBe(false)
    })
  })

  describe('findAll', () => {
    it('should return an empty array when no teams exist', async () => {
      // Act
      const result = await repository.findAll()

      // Assert
      const teams = expectSuccess(result)
      expect(teams).toEqual([])
    })

    it('should return all teams', async () => {
      // Arrange - Create 3 teams in parallel
      const teamsToCreate = Array.from({ length: 3 }, () => buildTeam())

      await Promise.all(teamsToCreate.map((team) => repository.save({ team })))

      // Act
      const result = await repository.findAll()

      // Assert
      const teams = expectSuccess(result)
      expect(teams).toHaveLength(3)

      const createdIds = teamsToCreate.map((team) => team.id)
      const foundIds = teams.map((team) => team.id)

      expect(foundIds).toEqual(expect.arrayContaining(createdIds))
    })
  })

  describe('findAllPaginated', () => {
    beforeEach(async () => {
      // Create 15 teams for pagination tests in parallel
      const teams = Array.from({ length: 15 }, () => buildTeam())
      await Promise.all(teams.map((team) => repository.save({ team })))
    })

    it('should return first page of teams with correct total', async () => {
      // Act
      const result = await repository.findAllPaginated({ limit: 10, page: 1 })

      // Assert
      const { teams, total } = expectSuccess(result)
      expect(teams).toHaveLength(10)
      expect(total).toBe(15)
    })

    it('should return second page of teams', async () => {
      // Act
      const result = await repository.findAllPaginated({ limit: 10, page: 2 })

      // Assert
      const { teams, total } = expectSuccess(result)
      expect(teams).toHaveLength(5) // Only 5 teams on second page
      expect(total).toBe(15)
    })

    it('should return empty array when page is beyond available data', async () => {
      // Act
      const result = await repository.findAllPaginated({ limit: 10, page: 3 })

      // Assert
      const { teams, total } = expectSuccess(result)
      expect(teams).toHaveLength(0)
      expect(total).toBe(15)
    })
  })

  describe('delete', () => {
    it('should delete a team by id', async () => {
      // Arrange
      const team = buildTeam()
      await repository.save({ team })

      // Act
      const result = await repository.delete({ id: team.id })

      // Assert
      expectSuccess(result)

      // Verify team was deleted
      const findResult = await repository.findById({ id: team.id })
      const foundTeam = expectSuccess(findResult)
      expect(foundTeam).toBeNull()
    })

    it('should not throw error when deleting non-existent team', async () => {
      // Act
      const randomTeam = buildTeam()
      const result = await repository.delete({ id: randomTeam.id })

      // Assert - Should succeed (idempotent delete)
      expectSuccess(result)
    })
  })

  describe('edge cases', () => {
    it('should handle teams with and without foundedYear', async () => {
      // Arrange
      const teamWithYear = buildTeam({ foundedYear: 2000 })
      const teamWithoutYear = buildTeam({ foundedYear: null })

      await repository.save({ team: teamWithYear })
      await repository.save({ team: teamWithoutYear })

      // Assert
      const allTeams = expectSuccess(await repository.findAll())
      expect(allTeams).toHaveLength(2)

      const foundWithYear = allTeams.find((team) => team.id === teamWithYear.id)
      const foundWithoutYear = allTeams.find((team) => team.id === teamWithoutYear.id)

      expect(foundWithYear?.foundedYear?.getValue()).toBe(2000)
      expect(foundWithoutYear?.foundedYear).toBeNull()
    })

    it('should handle timestamps correctly', async () => {
      // Arrange
      const team = buildTeam()
      await repository.save({ team })

      // Assert
      const foundTeam = expectSuccess(await repository.findById({ id: team.id }))
      expect(foundTeam).not.toBeNull()
      expect(foundTeam?.createdAt).toBeInstanceOf(Date)
      expect(foundTeam?.updatedAt).toBeInstanceOf(Date)

      // Basic sanity check on dates
      expect(foundTeam?.createdAt.getTime()).toBeLessThanOrEqual(Date.now())
    })

    it('should handle very old and very new founded years', async () => {
      // Arrange
      const oldTeam = buildTeam({ foundedYear: 1857 })
      const newTeam = buildTeam({ foundedYear: 2023 })

      await repository.save({ team: oldTeam })
      await repository.save({ team: newTeam })

      // Assert
      const foundOldTeam = expectSuccess(await repository.findById({ id: oldTeam.id }))
      const foundNewTeam = expectSuccess(await repository.findById({ id: newTeam.id }))

      expect(foundOldTeam?.foundedYear?.getValue()).toBe(1857)
      expect(foundNewTeam?.foundedYear?.getValue()).toBe(2023)
    })
  })
})
